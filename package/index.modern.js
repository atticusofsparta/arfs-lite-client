import{parse as t}from"uuid";import e from"axios";import*as r from"crypto";import i from"futoin-hkdf";import s from"utf8";import a from"jwk-to-pem";import"bignumber.js";import"base64-js";import*as n from"mime-types";import o from"arweave";let d;class h{constructor({gatewayUrl:t,maxRetriesPerRequest:r=8,initialErrorDelayMS:i=ot,fatalErrors:s=dt,validStatusCodes:a=[200],axiosInstance:n=e.create({validateStatus:void 0})}){this.gatewayUrl=void 0,this.maxRetriesPerRequest=void 0,this.initialErrorDelayMS=void 0,this.fatalErrors=void 0,this.validStatusCodes=void 0,this.axiosInstance=void 0,this.lastError="unknown error",this.lastRespStatus=0,this.gatewayUrl=t,this.maxRetriesPerRequest=r,this.initialErrorDelayMS=i,this.fatalErrors=s,this.validStatusCodes=a,this.axiosInstance=n}async postChunk(t){await this.postToEndpoint("chunk",t)}async postTxHeader(t){await this.postToEndpoint("tx",t)}async gqlRequest(t){try{const{data:e}=await this.postToEndpoint("graphql",t);return e.data.transactions}catch(t){throw Error(`GQL Error: ${t.message}`)}}async postToEndpoint(t,e){return this.retryRequestUntilMaxRetries(()=>this.axiosInstance.post(`${this.gatewayUrl.href}${t}`,e))}async getTransaction(t){try{return(await this.retryRequestUntilMaxRetries(()=>this.axiosInstance.get(`${this.gatewayUrl.href}tx/${t}`))).data}catch(t){throw Error(`Transaction could not be found from the gateway: (Status: ${this.lastRespStatus}) ${this.lastError}`)}}async getTxData(t){const e=await K.get(t);if(e)return e;const{data:r}=await this.retryRequestUntilMaxRetries(()=>this.axiosInstance.get(`${this.gatewayUrl.href}${t}`,{responseType:"arraybuffer"}));return await K.put(t,r),r}async retryRequestUntilMaxRetries(t){let e=0;for(;e<=this.maxRetriesPerRequest;){const r=await this.tryRequest(t);if(r)return e>0&&console.error("Request has been successfully retried!"),r;if(this.throwIfFatalError(),429===this.lastRespStatus){await this.rateLimitThrottle();continue}console.error(`Request to gateway has failed: (Status: ${this.lastRespStatus}) ${this.lastError}`);const i=e+1;i<=this.maxRetriesPerRequest&&(await this.exponentialBackOffAfterFailedRequest(e),console.error(`Retrying request, retry attempt ${i}...`)),e=i}throw new Error(`Request to gateway has failed: (Status: ${this.lastRespStatus}) ${this.lastError}`)}async tryRequest(t){try{var e;const r=await t();if(this.lastRespStatus=r.status,this.isRequestSuccessful())return r;this.lastError=null!=(e=r.statusText)?e:r}catch(t){this.lastError=t instanceof Error?t.message:t}}isRequestSuccessful(){return this.validStatusCodes.includes(this.lastRespStatus)}throwIfFatalError(){if(this.fatalErrors.includes(this.lastError))throw new Error(`Fatal error encountered: (Status: ${this.lastRespStatus}) ${this.lastError}`)}async exponentialBackOffAfterFailedRequest(t){const e=Math.pow(2,t)*this.initialErrorDelayMS;console.error(`Waiting for ${(e/1e3).toFixed(1)} seconds before next request...`),await new Promise(t=>setTimeout(t,e))}async rateLimitThrottle(){console.error(`Gateway has returned a ${this.lastRespStatus} status which means your IP is being rate limited. Pausing for ${60..toFixed(1)} seconds before trying next request...`),await new Promise(t=>setTimeout(t,6e4))}}d=Symbol.toPrimitive;class c{constructor(t){if(this.byteCount=void 0,this.byteCount=t,!Number.isFinite(this.byteCount)||!Number.isInteger(this.byteCount)||this.byteCount<0)throw new Error("Byte count must be a non-negative integer value!")}[d](t){return"string"===t&&this.toString(),this.byteCount}plus(t){return new c(this.byteCount+t.byteCount)}minus(t){return new c(this.byteCount-t.byteCount)}isGreaterThan(t){return this.byteCount>t.byteCount}isGreaterThanOrEqualTo(t){return this.byteCount>=t.byteCount}toString(){return`${this.byteCount}`}valueOf(){return this.byteCount}toJSON(){return this.byteCount}equals(t){return this.byteCount===t.byteCount}}const l=t=>`\n\tedges {\n\t\t${t?"":"cursor"}\n\t\t\n\tnode {\n\t\tid\n\t\ttags {\n\t\t\tname\n\t\t\tvalue\n\t\t}\n\t\t\n\towner {\n\t\taddress\n\t}\n\n\t}\n\n\t}\n`,u=ht?Object.values(ht):[];function p(){return p=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(t[i]=r[i])}return t},p.apply(this,arguments)}function y(t){let e="";const r=t.length;for(let i=0;i<r;i++)e+=String.fromCharCode(t[i]);return e}function v(t){const e=atob(t),r=e.length,i=new Uint8Array(r);for(let t=0;t<r;t++)i[t]=e.charCodeAt(t);return i}let w,f,g;w=Symbol.toPrimitive;class m{constructor(t){if(this.address=void 0,this.address=t,!new RegExp("^[a-zA-Z0-9_-]{43}$").test(t))throw new Error("Arweave addresses must be 43 characters in length with characters in the following set: [a-zA-Z0-9_-]")}[w](t){if("number"===t)throw new Error("Arweave addresses cannot be interpreted as a number!");return this.toString()}equals(t){return this.address===t.address}toString(){return this.address}valueOf(){return this.address}toJSON(){return this.toString()}}function I(t){return new m(t)}class T{constructor({password:t,driveKeys:e,wallet:r}){if(this.password=void 0,this.wallet=void 0,this.driveKeyCache={},this.unverifiedDriveKeys=void 0,t&&!r)throw new Error("Password supplied without a wallet. Did you forget to include your wallet?");if(t&&e)throw new Error("Password and drive keys can't be used together. Please provide one or the other.");this.unverifiedDriveKeys=null!=e?e:[],this.password=t,this.wallet=r}async safelyDecryptToJson(e,n,o,d){const h=this.driveKeyForDriveId(n);if(h)return this.decryptToJson(e,o,h);for(const t of this.unverifiedDriveKeys)try{const r=await this.decryptToJson(e,o,t);return this.driveKeyCache[`${n}`]=t,this.unverifiedDriveKeys=this.unverifiedDriveKeys.filter(e=>e!==t),r}catch(t){}if(this.password&&this.wallet){const d=await async function(e,n,o){const d=new Uint8Array(t(n)),h=function(...t){const e=t.reduce((t,e)=>t+e.length,0),r=new Uint8Array(e);let i=0;for(const e of t)r.set(e,i),i+=e.length;return r}(new Uint8Array(J(s.encode("drive"))),d),c=await async function(t,e){const i=r.createSign("sha256");i.update(e);const s=a(t,{private:!0});return i.sign({key:s,padding:r.constants.RSA_PKCS1_PSS_PADDING,saltLength:0})}(JSON.parse(o),h),l=y(new Uint8Array(J(s.encode(e)))),u=await i(y(c),32,{info:l,hash:"SHA-256"});return new S(u)}(this.password,`${n}`,JSON.stringify(this.wallet.getPrivateKey()));try{const t=await this.decryptToJson(e,o,d);return this.driveKeyCache[`${n}`]=d,t}catch(t){}}return d}async decryptToJson(t,e,i){const s=await async function(t,e,i){try{const s=16,a=i.slice(i.length-s),n=i.slice(0,i.length-s),o=v(t),d=v(y(e.keyData)),h=r.createDecipheriv("aes-256-gcm",d,o,{authTagLength:s});h.setAuthTag(a);const c=16,l=[];let u=h.update(n);for(;u.length>0;)l.push(u),u=h.update(new Uint8Array(c));const p=h.final();return p.length>0&&l.push(p),function(t){let e=0;for(const r of t)e+=r.length;const r=new Uint8Array(e);let i=0;for(const e of t)r.set(e,i),i+=e.length;return r}(l)}catch(t){return console.error("Error decrypting file data"),new Uint8Array([69,114,114,111,114])}}(t,i,e);return await q(s)}driveKeyForDriveId(t){var e;return null!=(e=this.driveKeyCache[`${t}`])&&e}}const b=/^[a-f\d]{8}-([a-f\d]{4}-){3}[a-f\d]{12}$/i;f=Symbol.toPrimitive;class F{constructor(t){if(this.entityId=void 0,this.entityId=t,t&&t.length&&!b.test(t.toString())&&"ENCRYPTED"!==t)throw new Error(`Invalid entity ID '${t}'!'`)}[f](t){if("number"===t)throw new Error("Entity IDs cannot be interpreted as a number!");return this.toString()}toString(){return this.entityId}valueOf(){return this.entityId}equals(t){return this.entityId===t.entityId}toJSON(){return this.toString()}}function D(t){return new F(t)}g=Symbol.toPrimitive;class x{constructor(t){if(this.unixTime=void 0,this.unixTime=t,this.unixTime<0||!Number.isInteger(this.unixTime)||!Number.isFinite(this.unixTime))throw new Error("Unix time must be a positive integer!")}equals(t){return+this.unixTime==+t.unixTime}[g](t){return"string"===t&&this.toString(),this.unixTime}toString(){return`${this.unixTime}`}valueOf(){return this.unixTime}toJSON(){return this.unixTime}}class S{constructor(t){if(this.keyData=void 0,this.keyData=t,!(t instanceof Uint8Array))throw new Error("The argument must be of type Uint8Array, got "+typeof t)}toString(){return function(t){let e="";const r=new Uint8Array(t),i=r.byteLength;for(let t=0;t<i;t++)e+=String.fromCharCode(r[t]);return btoa(e)}(this.keyData).replace(/=/g,"")}toJSON(){return this.toString()}}class E{constructor(t,e,r,i,s,a,n,o,d,h,c){this.appName=void 0,this.appVersion=void 0,this.arFS=void 0,this.contentType=void 0,this.driveId=void 0,this.entityType=void 0,this.name=void 0,this.txId=void 0,this.unixTime=void 0,this.customMetaDataGqlTags=void 0,this.customMetaDataJson=void 0,this.appName=t,this.appVersion=e,this.arFS=r,this.contentType=i,this.driveId=s,this.entityType=a,this.name=n,this.txId=o,this.unixTime=d,this.customMetaDataGqlTags=h,this.customMetaDataJson=c}}class A extends E{constructor(t,e,r,i,s,a,n,o,d,h,c,l,u,p,y,v,w){super(t,e,r,i,s,a,n,d,h,v,w),this.entityType=void 0,this.size=void 0,this.lastModifiedDate=void 0,this.dataTxId=void 0,this.dataContentType=void 0,this.parentFolderId=void 0,this.entityId=void 0,this.entityType=a,this.size=o,this.lastModifiedDate=c,this.dataTxId=l,this.dataContentType=u,this.parentFolderId=p,this.entityId=y}}class P{constructor({entityId:t,gatewayApi:e,owner:r}){this.appName=void 0,this.appVersion=void 0,this.arFS=void 0,this.contentType=void 0,this.driveId=void 0,this.entityType=void 0,this.name=void 0,this.txId=void 0,this.unixTime=void 0,this.entityId=void 0,this.gatewayApi=void 0,this.owner=void 0,this.customMetaData={},this.entityId=t,this.gatewayApi=e,this.owner=r}async getDataForTxID(t){return await this.gatewayApi.getTxData(t)}async parseFromArweaveNode(t,e){const r=[];if(!t){const r=C({tags:this.getGqlQueryParameters(),owner:e}),i=await this.gatewayApi.gqlRequest(r),{edges:s}=i;if(!s.length)throw new Error(`Entity with ID ${this.entityId} not found!`);t=s[0].node}this.txId=I(t.id);const{tags:i}=t;if(!i)throw new Error("Tags missing!");return i.forEach(t=>{const e=t.name,{value:i}=t;switch(e){case"App-Name":this.appName=i;break;case"App-Version":this.appVersion=i;break;case"ArFS":this.arFS=i;break;case"Content-Type":this.contentType=i;break;case"Drive-Id":this.driveId=D(i);break;case"Entity-Type":this.entityType=i;break;case"Unix-Time":this.unixTime=new x(+i);break;default:r.push(t)}}),r}async build(t){const e=await this.parseFromArweaveNode(t,this.owner);if(!e)throw new Error("Tags missing!");return this.parseCustomMetaDataFromGqlTags(e),this.buildEntity()}parseCustomMetaDataFromGqlTags(t){const e={};for(const{name:r,value:i}of t){const t=e[r],s=t?Array.isArray(t)?[...t,i]:[t,i]:i;Object.assign(e,{[r]:s})}!function(t){if("object"!=typeof t||null===t)return!1;for(const[e,r]of Object.entries(t)){if($.protectedArFSGqlTagNames.includes(e))return console.error(`Provided custom metadata GQL tag name collides with a protected ArFS protected tag: ${e}`),!1;if("string"!=typeof r){if(!Array.isArray(r))return!1;for(const t of r){if("string"!=typeof t)return!1;O(t)}}else O(r)}return!0}(e)?console.error(`Parsed an invalid custom metadata shape from MetaData Tx GQL Tags: ${e}`):Object.keys(e).length>0&&(this.customMetaData.metaDataGqlTags=e)}parseCustomMetaDataFromDataJson(t){if(!function(t){try{JSON.parse(JSON.stringify(t))}catch(t){return!1}return!0}(t))return void console.error(`Parsed an invalid custom metadata shape from MetaData Tx Data JSON: ${t}`);const e=Object.entries(t).filter(([t])=>!this.protectedDataJsonKeys.includes(t)),r={};for(const[t,i]of e)Object.assign(r,{[t]:i});Object.keys(r).length>0&&(this.customMetaData.metaDataJson=r)}}class N extends P{constructor(...t){super(...t),this.parentFolderId=void 0}async parseFromArweaveNode(t){const e=[],r=await super.parseFromArweaveNode(t);if(!r)throw new Error("Tags missing!");return r.forEach(t=>{const r=t.name,{value:i}=t;"Parent-Folder-Id"===r?this.parentFolderId=D(i):e.push(t)}),e}}class ${constructor({appName:t="default",appVersion:e="default",arFSVersion:r="default"}){this.appName=void 0,this.appVersion=void 0,this.arFSVersion=void 0,this.appName=t,this.appVersion=e,this.arFSVersion=r}get baseAppTags(){return[{name:"App-Name",value:this.appName},{name:"App-Version",value:this.appVersion}]}get baseArFSTags(){return[...this.baseAppTags,{name:"ArFS",value:this.arFSVersion}]}get baseBundleTags(){return[...this.baseAppTags,{name:"Bundle-Format",value:"binary"},{name:"Bundle-Version",value:"2.0.0"}]}getFileDataItemTags(t,e){const r=this.baseAppTags;return r.push(...t?[tt,et,rt]:[{name:"Content-Type",value:e}]),r}}function C({tags:t=[],cursor:e,owner:r,sort:i="HEIGHT_DESC",ids:s}){let a="";t.forEach(t=>{a=`${a}\n\t\t\t\t{ name: "${t.name}", values: ${Array.isArray(t.value)?`[${t.value.map(t=>`"${t.toString()}"`)}]`:`["${t.value.toString()}"]`} }`});const n=void 0===e;return{query:`query {\n\t\t\ttransactions(\n\t\t\t\t${null!=s&&s.length?`ids: [${s.map(t=>`"${t}"`)}]`:""}\n\t\t\t\tfirst: ${n?1:100}\n\t\t\t\tsort: ${i}\n\t\t\t\t${n?"":`after: "${e}"`}\n\t\t\t\t${void 0===r?"":`owners: ["${r.toString()}"]`}\n\t\t\t\ttags: [\n\t\t\t\t\t${a}\n\t\t\t\t]\n\t\t\t) {\n\t\t\t\t${n?"":"\n\tpageInfo {\n\t\thasNextPage\n\t}\n"}\n\t\t\t\t${l(n)}\n\t\t\t}\n\t\t}`}}function M(t){var e,r;const i=null!=(e=t.api.config.protocol)?e:st,s=null!=(r=t.api.config.host)?r:it;return new URL(`${i}://${s}${t.api.config.port?`:${t.api.config.port}`:""}/`)}async function q(t){let e,r,i,s,a;e="";const n=t.length;for(r=0;r<n;)switch(i=t[r++],i>>4){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:e+=String.fromCharCode(i);break;case 12:case 13:s=t[r++],e+=String.fromCharCode((31&i)<<6|63&s);break;case 14:s=t[r++],a=t[r++],e+=String.fromCharCode((15&i)<<12|(63&s)<<6|(63&a)<<0)}return e}function O(t){if(0===t.length)throw Error("Metadata string must be at least one character!")}function R(t,e,r){const i=r.filter(e=>e.entityId.equals(t.entityId));return t.txId.equals(i[0].txId)}function k(t,e,r){const i=r.filter(e=>e.driveId.equals(t.driveId));return t.txId.equals(i[0].txId)}function J(t){return(new TextEncoder).encode(t).buffer}$.protectedArFSGqlTagNames=u,p({},{created:[],tips:[],fees:{}},{manifest:{},links:[]});class V{constructor(t,e){this.dbPromise=void 0,this.cache=void 0,this._gatewayApi=void 0,this.dbPromise=this.initDatabase(t),this.dbPromise.then(t=>{this.cache=t}),this._gatewayApi=new h({gatewayUrl:M(null!=e?e:o.init({}))})}cacheKeyString(t){if("string"==typeof t)return t;if(t instanceof F||t instanceof m)return t.toString();if("driveId"in t){const e="string"==typeof t.driveId?t.driveId:t.driveId.toString();return t.owner?JSON.stringify({driveId:e,owner:t.owner}):JSON.stringify({driveId:e})}if("folderId"in t){const e=t.folderId.toString();return t.owner?JSON.stringify({folderId:e,owner:t.owner}):JSON.stringify({folderId:e})}if("fileId"in t){const e=t.fileId.toString();return t.owner?JSON.stringify({fileId:e,owner:t.owner}):JSON.stringify({fileId:e})}if("entityId"in t)return t.entityId.toString();throw new Error(`Unsupported cache key type: ${typeof t} : ${JSON.stringify(t)}`)}async initDatabase(t){return new Promise((t,e)=>{const r=indexedDB.open("arfs-entity-cache-db",1);r.onerror=t=>{console.debug(t),e(r.error)},r.onupgradeneeded=t=>{const e=r.result.createObjectStore("cache",{keyPath:"key"});e.createIndex("key","key",{unique:!0}),e.createIndex("value","value")},r.onsuccess=e=>{console.debug(e),t(r.result)}})}async put(t,e){const r=this.cacheKeyString(t),i=await this.dbPromise;return console.log("put",{cacheKey:r}),new Promise((t,s)=>{const a=i.transaction("cache","readwrite").objectStore("cache").put({key:r.toString(),value:e});a.onsuccess=r=>{t(e)},a.onerror=t=>{console.debug("Error putting in entity cache"),s(a.error)}})}async get(t){const e=this.cacheKeyString(t),r=await this.dbPromise;return console.log("get",{cacheKey:e}),new Promise((t,i)=>{const s=r.transaction("cache","readonly").objectStore("cache").index("key").get(e);s.onsuccess=e=>{const r=s.result;t(r?r.value:void 0)},s.onerror=t=>{i(s.error)}})}async remove(t){const e=this.cacheKeyString(t),r=await this.dbPromise;return new Promise((t,i)=>{const s=r.transaction("cache","readwrite").objectStore("cache"),a=s.index("key").getKey(e);a.onsuccess=e=>{const r=a.result;if(void 0!==r){const a=s.delete(r);a.onsuccess=()=>{t()},a.onerror=()=>{console.debug(e),i(a.error)}}else t()},a.onerror=t=>{console.debug(t),i(a.error)}})}async clear(){const t=await this.dbPromise;return new Promise((e,r)=>{const i=t.transaction("cache","readwrite").objectStore("cache").clear();i.onsuccess=t=>{console.debug(t),e()},i.onerror=t=>{console.debug(t),r(i.error)}})}async size(){const t=await this.dbPromise;return new Promise((e,r)=>{const i=t.transaction("cache","readonly").objectStore("cache").count();i.onsuccess=t=>{console.debug(t),e(i.result)},i.onerror=t=>{console.debug(t),r(i.error)}})}}class K{static platformCacheFolder(){return"metadata"}static async initDatabase(){return new Promise((t,e)=>{const r=indexedDB.open("arfs-metadata-cache-db",1);r.onerror=t=>{console.debug(t),e(r.error)},r.onupgradeneeded=t=>{const e=r.result.createObjectStore("cache",{keyPath:"txId"});e.createIndex("txId","txId",{unique:!0}),e.createIndex("buffer","buffer")},r.onsuccess=e=>{console.debug(e),t(r.result)}})}static async getCacheFolder(){return this.cacheFolderPromise||(this.cacheFolderPromise=new Promise(t=>{t(this.metadataCacheFolder)})),this.cacheFolderPromise}static async put(t,e){const r=await this.getDatabase();return new Promise((i,s)=>{const a=r.transaction("cache","readwrite").objectStore("cache").put({txId:t.toString(),buffer:e});a.onsuccess=t=>{console.debug(t),i()},a.onerror=t=>{console.debug(t),s(a.error)}})}static async get(t){const e=await this.getDatabase();return new Promise((r,i)=>{const s=e.transaction("cache","readonly").objectStore("cache").index("txId").get(t.toString());s.onsuccess=t=>{const e=s.result;e?(console.debug(t,e),r(e.buffer)):r(void 0)},s.onerror=t=>{console.debug(t),i(s.error)}})}static async getDatabase(){return this.dbPromise||(this.dbPromise=this.initDatabase()),this.dbPromise}}K.cacheFolderPromise=void 0,K.shouldCacheLog="1"===process.env.ARDRIVE_CACHE_LOG,K.metadataCacheFolder=K.platformCacheFolder(),K.logTag="[Metadata Cache] ",K.dbPromise=void 0;const _={ownerCache:new V(10),driveIdCache:new V(10),publicDriveCache:new V(10),publicFolderCache:new V(10),publicFileCache:new V(10)};class U extends A{constructor(t,e,r,i,s,a,n,o,d,h,c,l,u,p,y,v){super(t,e,r,i,s,"file",a,c,n,o,l,u,p,d,h,y,v),this.fileId=void 0,this.fileId=h}}class j extends U{constructor(t,e){super(t.appName,t.appVersion,t.arFS,t.contentType,t.driveId,t.name,t.txId,t.unixTime,t.parentFolderId,t.fileId,t.size,t.lastModifiedDate,t.dataTxId,t.dataContentType,t.customMetaDataGqlTags,t.customMetaDataJson),this.path=void 0,this.txIdPath=void 0,this.entityIdPath=void 0,this.path=`${e.pathToFolderId(t.parentFolderId)}${t.name}`,this.txIdPath=`${e.txPathToFolderId(t.parentFolderId)}${t.txId}`,this.entityIdPath=`${e.entityPathToFolderId(t.parentFolderId)}${t.fileId}`}}class G extends N{constructor(...t){super(...t),this.size=void 0,this.lastModifiedDate=void 0,this.dataTxId=void 0,this.dataContentType=void 0,this.protectedDataJsonKeys=["name","size","lastModifiedDate","dataTxId","dataContentType"]}getGqlQueryParameters(){return[{name:"File-Id",value:`${this.entityId}`},{name:"Entity-Type",value:"file"}]}async parseFromArweaveNode(t){const e=await super.parseFromArweaveNode(t);if(!e)throw new Error("Tags missing!");return e.filter(t=>"File-Id"!==t.name)}}class z extends G{static fromArweaveNode(t,e){var r;const{tags:i}=t;if(!i)throw new Error("Tags missing!");const s=null==(r=i.find(t=>"File-Id"===t.name))?void 0:r.value;if(!s)throw new Error("File-ID tag missing!");return new z({entityId:D(s),gatewayApi:e})}async buildEntity(){var t,e,r,i,s;if(null!=(t=this.appName)&&t.length&&null!=(e=this.appVersion)&&e.length&&null!=(r=this.arFS)&&r.length&&null!=(i=this.contentType)&&i.length&&this.driveId&&null!=(s=this.entityType)&&s.length&&this.txId&&this.unixTime&&this.parentFolderId&&this.entityId){var a;const t=await this.getDataForTxID(this.txId),e=await q(new Uint8Array(t)),r=await JSON.parse(e);if(this.name=r.name,this.size=new c(r.size),this.lastModifiedDate=new x(r.lastModifiedDate),this.dataTxId=new m(r.dataTxId),this.dataContentType=null!=(a=r.dataContentType)?a:function(t){let e=t.substring(t.lastIndexOf(".")+1);e=e.toLowerCase();const r=n.lookup(e);return!1===r?"unknown":r}(this.name),!(this.name&&void 0!==this.size&&this.lastModifiedDate&&this.dataTxId&&this.dataContentType&&"file"===this.entityType))throw new Error("Invalid file state");return this.parseCustomMetaDataFromDataJson(r),Promise.resolve(new U(this.appName,this.appVersion,this.arFS,this.contentType,this.driveId,this.name,this.txId,this.unixTime,this.parentFolderId,this.entityId,this.size,this.lastModifiedDate,this.dataTxId,this.dataContentType,this.customMetaData.metaDataGqlTags,this.customMetaData.metaDataJson))}throw new Error("Invalid file state")}}new c(2147483646);class L extends A{constructor(t,e,r,i,s,a,n,o,d,h,l,u){super(t,e,r,i,s,"folder",a,new c(0),n,o,new x(0),ct,X,d,h,l,u),this.folderId=void 0,this.folderId=h}}class B extends L{constructor(t,e){super(t.appName,t.appVersion,t.arFS,t.contentType,t.driveId,t.name,t.txId,t.unixTime,t.parentFolderId,t.folderId,t.customMetaDataGqlTags,t.customMetaDataJson),this.path=void 0,this.txIdPath=void 0,this.entityIdPath=void 0,this.path=`${e.pathToFolderId(t.parentFolderId)}${t.name}`,this.txIdPath=`${e.txPathToFolderId(t.parentFolderId)}${t.txId}`,this.entityIdPath=`${e.entityPathToFolderId(t.parentFolderId)}${t.folderId}`}}class Q{constructor(t,e,r=[]){this.folderId=void 0,this.parent=void 0,this.children=void 0,this.folderId=t,this.parent=e,this.children=r}static fromEntity(t){return new Q(t.entityId)}}class H{constructor(t,e){this.folderIdToEntityMap=void 0,this.folderIdToNodeMap=void 0,this._rootNode=void 0,this.folderIdToEntityMap=t,this.folderIdToNodeMap=e}static newFromEntities(t){const e=t.reduce((t,e)=>Object.assign(t,{[`${e.entityId}`]:e}),{}),r={};for(const i of t)this.setupNodesWithEntity(i,e,r);return new H(e,r)}static setupNodesWithEntity(t,e,r){const i=Object.keys(r).includes(`${t.entityId}`),s=Object.keys(r).includes(`${t.parentFolderId}`);if(!i){if(!s){const i=e[`${t.parentFolderId}`];i&&this.setupNodesWithEntity(i,e,r)}const i=r[`${t.parentFolderId}`];if(i){const e=new Q(t.entityId,i);i.children.push(e),r[`${t.entityId}`]=e}else{const e=new Q(t.entityId);r[`${t.entityId}`]=e}}}get rootNode(){if(this._rootNode)return this._rootNode;const t=Object.keys(this.folderIdToEntityMap)[0];let e=this.folderIdToNodeMap[t];for(;e.parent&&this.folderIdToNodeMap[`${e.parent.folderId}`];)e=e.parent;return this._rootNode=e,e}subTreeOf(t,e=Number.MAX_SAFE_INTEGER){const r=this.nodeAndChildrenOf(this.folderIdToNodeMap[`${t}`],e),i=r.reduce((t,e)=>Object.assign(t,{[`${e.folderId}`]:this.folderIdToEntityMap[`${e.folderId}`]}),{}),s=r.reduce((t,e)=>Object.assign(t,{[`${e.folderId}`]:e}),{});return new H(i,s)}allFolderIDs(){return Object.keys(this.folderIdToEntityMap).map(t=>D(t))}nodeAndChildrenOf(t,e){const r=[t];return e>0&&t.children.forEach(t=>{r.push(...this.nodeAndChildrenOf(t,e-1))}),r}folderIdSubtreeFromFolderId(t,e){const r=this.folderIdToNodeMap[`${t}`],i=[r.folderId];return 0===e||r.children.map(t=>t.folderId).forEach(t=>{i.push(...this.folderIdSubtreeFromFolderId(t,e-1))}),i}pathToFolderId(t){if(this.rootNode.parent)throw new Error("Can't compute paths from sub-tree");if(`${t}`===at)return"/";let e=this.folderIdToNodeMap[`${t}`];const r=[e];for(;e.parent&&!e.folderId.equals(this.rootNode.folderId);)e=e.parent,r.push(e);return`/${r.reverse().map(t=>this.folderIdToEntityMap[`${t.folderId}`].name).join("/")}/`}entityPathToFolderId(t){if(this.rootNode.parent)throw new Error("Can't compute paths from sub-tree");if(`${t}`===at)return"/";let e=this.folderIdToNodeMap[`${t}`];const r=[e];for(;e.parent&&!e.folderId.equals(this.rootNode.folderId);)e=e.parent,r.push(e);return`/${r.reverse().map(t=>t.folderId).join("/")}/`}txPathToFolderId(t){if(this.rootNode.parent)throw new Error("Can't compute paths from sub-tree");if(`${t}`===at)return"/";let e=this.folderIdToNodeMap[`${t}`];const r=[e];for(;e.parent&&!e.folderId.equals(this.rootNode.folderId);)e=e.parent,r.push(e);return`/${r.reverse().map(t=>this.folderIdToEntityMap[`${t.folderId}`].txId).join("/")}/`}}class W extends N{constructor(...t){super(...t),this.protectedDataJsonKeys=["name"]}async parseFromArweaveNode(t){const e=await super.parseFromArweaveNode(t);if(!e)throw new Error("Tags missing!");return e.filter(t=>"Folder-Id"!==t.name)}getGqlQueryParameters(){return[{name:"Folder-Id",value:`${this.entityId}`},{name:"Entity-Type",value:"folder"}]}}class Y extends F{constructor(){super(`${lt}`),this.entityId=at}}class Z extends W{static fromArweaveNode(t,e){var r;const{tags:i}=t;if(!i)throw new Error("Tags missing!");const s=null==(r=i.find(t=>"Folder-Id"===t.name))?void 0:r.value;if(!s)throw new Error("Folder-ID tag missing!");return new Z({entityId:D(s),gatewayApi:e})}async buildEntity(){var t,e,r,i,s;if(this.parentFolderId||(this.parentFolderId=new Y),null!=(t=this.appName)&&t.length&&null!=(e=this.appVersion)&&e.length&&null!=(r=this.arFS)&&r.length&&null!=(i=this.contentType)&&i.length&&this.driveId&&null!=(s=this.entityType)&&s.length&&this.txId&&this.unixTime&&this.parentFolderId&&this.entityId&&"folder"===this.entityType){const t=await this.getDataForTxID(this.txId),e=await q(new Uint8Array(t)),r=JSON.parse(e);if(this.name=r.name,!this.name)throw new Error("Invalid public folder state: name not found!");return this.parseCustomMetaDataFromDataJson(r),Promise.resolve(new L(this.appName,this.appVersion,this.arFS,this.contentType,this.driveId,this.name,this.txId,this.unixTime,this.parentFolderId,this.entityId,this.customMetaData.metaDataGqlTags,this.customMetaData.metaDataJson))}throw new Error("Invalid public folder state")}}const X="application/json",tt={name:"Content-Type",value:"application/octet-stream"},et={name:"Cipher",value:"AES256-GCM"},rt={name:"Cipher-IV",value:"qwertyuiopasdfgh"},it="arweave.net",st="https",at="root folder",nt="ENCRYPTED",ot=500,dt=["invalid_json","chunk_too_big","data_path_too_big","offset_too_big","data_size_too_big","chunk_proof_ratio_not_attractive","invalid_proof"],ht={arFS:"ArFS",tipType:"Tip-Type",contentType:"Content-Type",boost:"Boost",bundleFormat:"Bundle-Format",bundleVersion:"Bundle-Version",entityType:"Entity-Type",unitTime:"Unix-Time",driveId:"Drive-Id",folderId:"Folder-Id",fileId:"File-Id",parentFolderId:"Parent-Folder-Id",drivePrivacy:"Drive-Privacy",cipher:"Cipher",cipherIv:"Cipher-IV",driveAuthMode:"Drive-Auth-Mode"},ct=new m("0000000000000000000000000000000000000000000"),lt=D("00000000-0000-0000-0000-000000000000");class ut extends E{constructor(t,e,r,i,s,a,n,o,d,h,c,l,u){super(t,e,r,i,s,a,n,o,d,l,u),this.appName=void 0,this.appVersion=void 0,this.arFS=void 0,this.contentType=void 0,this.driveId=void 0,this.entityType=void 0,this.name=void 0,this.txId=void 0,this.unixTime=void 0,this.drivePrivacy=void 0,this.rootFolderId=void 0,this.appName=t,this.appVersion=e,this.arFS=r,this.contentType=i,this.driveId=s,this.entityType=a,this.name=n,this.txId=o,this.unixTime=d,this.drivePrivacy=h,this.rootFolderId=c}}class pt extends E{constructor(t,e,r,i,s,a,n,o,d,h,c,l,u,p,y,v,w){super(t,e,r,i,s,a,n,o,d,v,w),this.appName=void 0,this.appVersion=void 0,this.arFS=void 0,this.contentType=void 0,this.driveId=void 0,this.entityType=void 0,this.name=void 0,this.txId=void 0,this.unixTime=void 0,this.drivePrivacy=void 0,this.rootFolderId=void 0,this.driveAuthMode=void 0,this.cipher=void 0,this.cipherIV=void 0,this.driveKey=void 0,this.appName=t,this.appVersion=e,this.arFS=r,this.contentType=i,this.driveId=s,this.entityType=a,this.name=n,this.txId=o,this.unixTime=d,this.drivePrivacy=h,this.rootFolderId=c,this.driveAuthMode=l,this.cipher=u,this.cipherIV=p,this.driveKey=y}}class yt extends P{constructor(...t){super(...t),this.protectedDataJsonKeys=["name","rootFolderId"]}}class vt extends yt{constructor(...t){super(...t),this.drivePrivacy=void 0,this.rootFolderId=void 0}static fromArweaveNode(t,e){var r;const{tags:i}=t;if(!i)throw new Error("Tags missing!");const s=null==(r=i.find(t=>"Drive-Id"===t.name))?void 0:r.value;if(!s)throw new Error("Drive-ID tag missing!");return new vt({entityId:D(s),gatewayApi:e})}getGqlQueryParameters(){return[{name:"Drive-Id",value:`${this.entityId}`},{name:"Entity-Type",value:"drive"},{name:"Drive-Privacy",value:"public"}]}async parseFromArweaveNode(t){const e=[],r=await super.parseFromArweaveNode(t);if(!r)throw new Error("Tags missing!");return r.forEach(t=>{const r=t.name,{value:i}=t;"Drive-Privacy"===r?this.drivePrivacy=i:e.push(t)}),e}async buildEntity(){var t,e,r,i,s,a;if(null!=(t=this.appName)&&t.length&&null!=(e=this.appVersion)&&e.length&&null!=(r=this.arFS)&&r.length&&null!=(i=this.contentType)&&i.length&&this.driveId&&null!=(s=this.entityType)&&s.length&&this.txId&&this.unixTime&&this.driveId.equals(this.entityId)&&null!=(a=this.drivePrivacy)&&a.length){const t=await this.getDataForTxID(this.txId),e=await q(new Uint8Array(t)),r=await JSON.parse(e);if(this.name=r.name,this.rootFolderId=r.rootFolderId,!this.name||!this.rootFolderId)throw new Error("Invalid drive state");return this.parseCustomMetaDataFromDataJson(r),new ut(this.appName,this.appVersion,this.arFS,this.contentType,this.driveId,this.entityType,this.name,this.txId,this.unixTime,this.drivePrivacy,this.rootFolderId,this.customMetaData.metaDataGqlTags,this.customMetaData.metaDataJson)}throw new Error("Invalid drive state")}}class wt extends yt{constructor({entityId:t,privateKeyData:e,gatewayApi:r}){super({entityId:t,gatewayApi:r}),this.drivePrivacy=void 0,this.rootFolderId=void 0,this.driveAuthMode=void 0,this.cipher=void 0,this.cipherIV=void 0,this.privateKeyData=void 0,this.privateKeyData=e}getGqlQueryParameters(){return[{name:"Drive-Id",value:`${this.entityId}`},{name:"Entity-Type",value:"drive"}]}static fromArweaveNode(t,e,r){var i;const{tags:s}=t;if(!s)throw new Error("Tags missing!");const a=null==(i=s.find(t=>"Drive-Id"===t.name))?void 0:i.value;if(!a)throw new Error("Drive-ID tag missing!");return new wt({entityId:D(a),privateKeyData:r,gatewayApi:e})}async parseFromArweaveNode(t){const e=[],r=await super.parseFromArweaveNode(t);if(!r)throw new Error("Tags missing!");return r.forEach(t=>{const r=t.name,{value:i}=t;switch(r){case"Cipher":this.cipher=i;break;case"Cipher-IV":this.cipherIV=i;break;case"Drive-Auth-Mode":this.driveAuthMode=i;break;case"Drive-Privacy":this.drivePrivacy=i;break;default:e.push(t)}}),e}async buildEntity(){var t,e,r,i,s,a,n=this;if(null!=(t=this.appName)&&t.length&&null!=(e=this.appVersion)&&e.length&&null!=(r=this.arFS)&&r.length&&null!=(i=this.contentType)&&i.length&&this.driveId&&null!=(s=this.entityType)&&s.length&&this.txId&&this.unixTime&&null!=(a=this.drivePrivacy)&&a.length){const t="private"===this.drivePrivacy,e=await this.getDataForTxID(this.txId),r=new Uint8Array(e),i=await async function(){if(t){var i,s,a;if(null!=(i=n.cipher)&&i.length&&null!=(s=n.driveAuthMode)&&s.length&&null!=(a=n.cipherIV)&&a.length)return n.privateKeyData.safelyDecryptToJson(n.cipherIV,n.entityId,r,{name:nt,rootFolderId:nt});throw new Error("Invalid private drive state")}return JSON.parse(await q(new Uint8Array(e)))}();if(this.name=i.name,this.rootFolderId=D(i.rootFolderId),this.parseCustomMetaDataFromDataJson(i),t){if(!this.driveAuthMode||!this.cipher||!this.cipherIV)throw new Error(`Unexpectedly null privacy data for private drive with ID ${this.driveId}!`);return new ft(this.appName,this.appVersion,this.arFS,this.contentType,this.driveId,this.entityType,this.name,this.txId,this.unixTime,this.drivePrivacy,this.rootFolderId,this.driveAuthMode,this.cipher,this.cipherIV,this.customMetaData.metaDataGqlTags,this.customMetaData.metaDataJson)}return new ut(this.appName,this.appVersion,this.arFS,this.contentType,this.driveId,this.entityType,this.name,this.txId,this.unixTime,this.drivePrivacy,this.rootFolderId,this.customMetaData.metaDataGqlTags,this.customMetaData.metaDataJson)}throw new Error("Invalid drive state")}}class ft extends pt{constructor(t,e,r,i,s,a,n,o,d,h,c,l,u,p,y,v){super(t,e,r,i,s,a,n,o,d,h,c,l,u,p,new S(new Uint8Array([])),y,v),this.driveKey=void 0,this.driveKey=new S(new Uint8Array([])),delete this.driveKey}}class gt{constructor(t,e=_,r=new h({gatewayUrl:M(t)})){this.caches=void 0,this.gatewayApi=void 0,this._arweave=void 0,this._gatewayApi=void 0,this._caches=void 0,this.appName=void 0,this.appVersion=void 0,this.caches=e,this.gatewayApi=r,this._arweave=t,this._gatewayApi=r,this._caches=e,this.appName="ArFS",this.appVersion="0.0.1"}async getOwnerForDriveId(t){var e=this;return await this.caches.ownerCache.get(t)||this.caches.ownerCache.put(t,await async function(){const r=C({tags:[{name:"Drive-Id",value:`${t}`},{name:"Entity-Type",value:"drive"}],sort:"HEIGHT_ASC"}),i=(await e.gatewayApi.gqlRequest(r)).edges;if(!i.length)throw new Error(`Could not find a transaction with "Drive-Id": ${t.toString()}`);return I(i[0].node.owner.address)}())}async getDriveIDForEntityId(t,e){var r=this;console.log("getDriveIDForEntityId : get",t);const i=await this.caches.driveIdCache.get(t);if(i)return i;const s=await(async function(){const i=C({tags:[{name:e,value:`${t}`}]}),s=(await r.gatewayApi.gqlRequest(i)).edges;if(!s.length)throw new Error(`Entity with ${e} ${t.toString()} not found!`);const a=s[0].node.tags.find(t=>"Drive-Id"===t.name);if(a)return D(a.value);throw new Error(`No Drive-Id tag found for meta data transaction of ${e}: ${t.toString()}`)});return console.log("getDriveIDForEntityId : put",t),await this.caches.driveIdCache.put(t,await s())}async getDriveOwnerForFolderId(t){return this.getOwnerForDriveId(await this.getDriveIdForFolderId(t))}async getDriveIdForFolderId(t){return this.getDriveIDForEntityId(t,"Folder-Id")}async getDriveOwnerForFileId(t){return this.getOwnerForDriveId(await this.getDriveIdForFileId(t))}async getDriveIdForFileId(t){return this.getDriveIDForEntityId(t,"File-Id")}async getDriveIdForEntityID(t){return this.getDriveIDForEntityId(t,"Folder-Id")}async getPublicDrive({driveId:t,owner:e}){const r={driveId:t.toString(),owner:e};return await this.caches.publicDriveCache.get(r)||await this.caches.publicDriveCache.put(r,await new vt({entityId:t,gatewayApi:this.gatewayApi,owner:e}).build())}async getPublicFolder({folderId:t,owner:e}){const r={folderId:t,owner:e};return console.log("getPublicFolder : get",{cacheKey:r}),await this.caches.publicFolderCache.get(r)||(console.log("getPublicFolder : put",{cacheKey:r}),await this.caches.publicFolderCache.put(r,await new Z({entityId:t,gatewayApi:this.gatewayApi,owner:e}).build()))}async getPublicFile({fileId:t,owner:e}){const r={fileId:t,owner:e};return console.log("getPublicFile : get",{cacheKey:r}),await this.caches.publicFileCache.get(r)||(console.log("getPublicFile : put",{cacheKey:r}),await this.caches.publicFileCache.put(r,await new z({entityId:t,gatewayApi:this.gatewayApi,owner:e}).build()))}async getAllDrivesForAddress({address:t,privateKeyData:e,latestRevisionsOnly:r=!0}){var i=this;const s=new m(t);let a="",n=!0;const o=[];for(;n;){const t=C({tags:[{name:"Entity-Type",value:"drive"}],cursor:a,owner:s}),r=await this.gatewayApi.gqlRequest(t),{edges:d}=r;n=r.pageInfo.hasNextPage;const h=d.map(async function(t){const{node:r}=t;a=t.cursor;const n=wt.fromArweaveNode(r,i.gatewayApi,e),o=await n.build(r);if("public"===o.drivePrivacy){const t={driveId:o.driveId,owner:s};return await i.caches.publicDriveCache.put(t,await Promise.resolve(o))}return Promise.resolve(o)});o.push(...await Promise.all(h))}return r?o.filter(k):o}async getPublicFilesWithParentFolderIds({folderIDs:t,owner:e,latestRevisionsOnly:r=!1}){var i=this;let s="",a=!0;const n=[];for(;a;){const r=C({tags:[{name:"Parent-Folder-Id",value:t.map(t=>t.toString())},{name:"Entity-Type",value:"file"}],cursor:s,owner:e}),o=await this.gatewayApi.gqlRequest(r),{edges:d}=o;a=o.pageInfo.hasNextPage;const h=d.map(async function(t){const{node:r}=t;s=t.cursor;const a=z.fromArweaveNode(r,i.gatewayApi),o=await a.build(r),d={fileId:o.fileId,owner:e};return n.push(o),await i.caches.publicFileCache.put(d,await Promise.resolve(o))});await Promise.all(h)}return r?n.filter(R):n}async getAllFoldersOfPublicDrive({driveId:t,owner:e,latestRevisionsOnly:r=!1}){var i=this;let s="",a=!0;const n=[];for(;a;){const r=C({tags:[{name:"Drive-Id",value:`${t.toString()}`},{name:"Entity-Type",value:"folder"}],cursor:s,owner:e}),o=await this.gatewayApi.gqlRequest(r),{edges:d}=o;a=o.pageInfo.hasNextPage;const h=d.map(async function(t){const{node:r}=t;s=t.cursor;const a=Z.fromArweaveNode(r,i.gatewayApi),n=await a.build(r),o={folderId:n.entityId,owner:e};return await i.caches.publicFolderCache.put(o,await Promise.resolve(n))});n.push(...await Promise.all(h))}return r?n.filter(R):n}async listPublicFolder({folderId:t,maxDepth:e,includeRoot:r,owner:i}){if(!Number.isInteger(e)||e<0)throw new Error("maxDepth should be a non-negative integer!");const s=await this.getPublicFolder({folderId:t,owner:i}),a=s.driveId,n=await this.getAllFoldersOfPublicDrive({driveId:a,owner:i,latestRevisionsOnly:!0}),o=H.newFromEntities(n),d=o.folderIdSubtreeFromFolderId(t,e),[,...h]=o.folderIdSubtreeFromFolderId(t,e+1),c=n.filter(t=>h.some(e=>e.equals(t.entityId)));r&&c.unshift(s);const l=[];for(const t of d)(await this.getPublicFilesWithParentFolderIds({folderIDs:[t],owner:i,latestRevisionsOnly:!0})).forEach(t=>{l.push(t)});const u=[];for(const t of c)u.push(t);for(const t of l)u.push(t);const p=u.map(t=>function(t,e){return"folder"===t.entityType?new B(t,e):new j(t,e)}(t,o));return p}}export{gt as ArFSClient,ut as ArFSPublicDrive,U as ArFSPublicFile,L as ArFSPublicFolder,m as ArweaveAddress,F as EntityID,T as PrivateKeyData};
